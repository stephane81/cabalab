unit dlldecl;
{**************************************************************************}
{                                                                          }
{    This C DLL header file first (automatic) conversion generated by:     }
{    HeadConv 4.0 (c) 2000 by Bob Swart (aka Dr.Bob - www.drbob42.com)     }
{      Final Delphi-Jedi (Darth) command-line units edition                }
{                                                                          }
{    Generated Date: 02/02/2006                                            }
{    Generated Time: 20:34:11                                              }
{                                                                          }
{**************************************************************************}

interface
uses Windows, SysUtils, Forms,Inifiles;



{$IFNDEF AFX_GTICOMMX_H__0F384D80_6AF9_11DA_A5B7_000244639032__INCLUDED_}
{$DEFINE AFX_GTICOMMX_H__0F384D80_6AF9_11DA_A5B7_000244639032__INCLUDED_}

function DoEvents: LongInt cdecl stdcall;
//en fait procedure function void en C ?

const GTI2 = true ;
      HS3 = false ;
      {*
       *  Taille du TABLEAU GTI2
       *}
      Tgti2MAX = 16384;


     {*
      * Return codes = bit values -> usualy an error
      *}
      E_NO_ERRORS       = $0000;       { 0000 0000 0000 0000 }
      E_NO_HARDWARE     = $0001;       { 0000 0000 0000 0001 }
      E_NOT_INITIALIZED = $0002;       { 0000 0000 0000 0010 }
      E_NOT_SUPPORTED   = $0004;       { 0000 0000 0000 0100 }
      E_NO_GENERATOR    = $0008;       { 0000 0000 0000 1000 }
      E_INVALID_CHANNEL = $0010;       { 0000 0000 0001 0000 }
      E_INVALID_VALUE   = $0020;       { 0000 0000 0010 0000 }
      E_NO_TRIGGER      = $0040;
      E_NO_data_Complet = $0080;
      E_NO_DATA         = $0100;
     {*
      * Other useful constants
      *
      * Channel constants
      * DO NOT USE FOR Get/SetMeasureMode !!!
      *}
      lCh1              = 1;
      lCh2              = 2;
      lCh3              = 3;
      lCh4              = 4;
     {*
      * Measure mode constants
      * To measure more than one channel, simply add the required sonsts together: mCh1 + mCh2
      *}
      mCh1              = 1;
      mCh2              = 2;
      mCh3              = 4;
      mCh4              = 8;
      mCh12             = 3;
     {*
      * Coupling constants
      *}
      lctAC             = 0;
      lctDC             = 1;
     {*
      * Trigger mode constants
      *}
      ltkRising         =  0; { Trigger when signal passes level in positive direction       }
      ltkFalling        =  1; { Trigger when signal passes level in negative direction       }
      ltkInWindow       =  2; { Trigger when signal gets inside marked window                }
      ltkOutWindow      =  3; { Trigger when signal gets outside marked window               }
      ltkTVLine         =  4; { Trigger at TV line sync pulse                                }
      ltkTVFieldOdd     =  5; { Trigger at Odd TV field sync pulse                           }
      ltkTVFieldEven    =  6; { Trigger at Even TV field sync pulse                          }
     {*
      * Trigger source constants
      *}
      ltsCh1            = 0;
      ltsCh2            = 1;
      ltsCh3            = 2;
      ltsCh4            = 3;
      ltsExternal       = 4;
      ltsAnaExt         = 5;
      ltsAnd            = 6;
      ltsOr             = 7;
      ltsXor            = 8;
      ltsNoTrig         = 9;
      ltsNeverTrig      = 10;  { not used }
      ltsPxiExt         = 11;
      ltsGenStart       = 12;
      ltsGenStop        = 13;
      ltsGenNew         = 14;
     {*
      * function generator signal type constants
      *}
      lstSine           = 0;
      lstTriangle       = 1;
      lstSquare         = 2;
      lstDC             = 3;
      lstNoise          = 4;
      lstarbitrary      = 5;


//****************************************
// Structure de Communication
//**************************************

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
type
  _DATA_GTI = record
    lDataLen1: LongInt;
    lDataLen2: LongInt;
    lDataLen3: LongInt;
    lDataLen4: LongInt;
    bBufferIn1: Array[0..256-1] of LongInt;
    bBufferIn2: Array[0..256-1] of LongInt;
    bBufferIn3: Array[0..256-1] of LongInt;
    bBufferIn4: Array[0..256-1] of LongInt;
  end {_DATA_GTI};
  DATA_GTI = _DATA_GTI;

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
type
  _DATA_GENERATEUR = record
    NbreData: LongInt;
    BaseDeTemps: byte;
    Reload: LongInt;
    BufferOut: Array[0..16000-1] of LongInt; //( -2147483648  2147483647 )
  end {_DATA_GENERATEUR};
  DATA_GENERATEUR = _DATA_GENERATEUR;
  PDATA_GENERATEUR = ^DATA_GENERATEUR ;
//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
type
  _ACQUISITION_VOIE = record
    On: UCHAR;
    Calibre: UCHAR;
    Differentiel: UCHAR;
  end {_ACQUISITION_VOIE};
  ACQUISITION_VOIE = _ACQUISITION_VOIE;

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
type
  _ACQUISITION_TRIG = record
    TrigOn: UCHAR;
    PreTrigOn: UCHAR;
    FrontMontant: UCHAR;
    Valeur: LongInt;
  end {_ACQUISITION_TRIG};
  ACQUISITION_TRIG = _ACQUISITION_TRIG;

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
type
  _ACQUISITION_CONFIG = record
    BaseDeTemps: UCHAR;
    Reload: UCHAR;
    UnSurN: LongInt;
  end {_ACQUISITION_CONFIG};
  ACQUISITION_CONFIG = _ACQUISITION_CONFIG;

//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
type
  _DATA_ACQUISITION = record
    Calibrage: UCHAR;
    Voie: Array[0..4-1] of ACQUISITION_VOIE;
    Config: ACQUISITION_CONFIG;
    Trig: ACQUISITION_TRIG;
  end {_DATA_ACQUISITION};
  DATA_ACQUISITION = _DATA_ACQUISITION;

//function GtiCommX: UBLIC: cdecl stdcall;

//function ~GtiCommX: VIRTUAL cdecl stdcall;



type pdouble = ^double;
     Tab20double = array[0..19] of double;
     PTab20double = ^tab20double;
     TWArray    = array [0..{131092}512 * 1024] of word;
     TWArray2   = array [0..{131092}512 * 1024] of word;
     PTWArray   = ^TWArray;
     PTWArray2   = ^TWArray2;
  // DArray     = array[0..{131092}512 * 1024] of double;
     DArray     = array[0..Tgti2MAX] of double;
     PDArray    = ^DArray;

  TFichier = record
          IndiceFrequence  : integer;
          NbreData   : word; // nb pts
          Frequence  : array [0 .. 100000] of double;
          NbFrequences:integer;
          BasedeTemps: array [0 .. 100000] of byte;
          Reload     : array [0 .. 100000] of word;
          BufferOut  : array [0 .. 15999 ] of longint;  // stockage des points

          end;

  TGenerateur = record
      TypeSignal : word ;
      Amplitude  : double ;
      Offset     : double ;
      Correction_Amplitude : double ;  //SE correction défaut d'offset du GBF // valeur en Volt
      Symetrie   : double ;
      Allume     : word ;
      Multicoup   : word ;
      IndiceFrequence  : integer;
      Frequence  : array [0 .. 100000] of double; //10000 par décade
      NbFrequences:integer;
      NbreData   : array [0 .. 100000] of word;
      BasedeTemps: array [0 .. 100000] of byte;
      Reload     : array [0 .. 100000] of word;
      BufferOut  : array [0 .. 15999 ] of longint;
      Fichier    : TFichier;
      end;

  TAcquisition = record
      Frequence  : array [0 .. 100000] of dword;
      Reload     : array [0 .. 100000] of word;
      BasedeTemps: array [0 .. 100000] of byte;
      UnSurN     : array [0 .. 100000] of longint;
      NbFrequences:integer;
      IndiceFrequence  : integer;
      RecordLength : dword;
      TriggerLevel    : array [1..4] of double; // TiePie un level par voie, GTI2 non
      TriggerTimeOut  : dword;
      NbDataUSB  : integer ;
      Correction_Amplitude_Unipolaire : array [1..4] of double ;  //SE correction défaut d'offset des 4 voies // valeur en Volt
      Correction_Amplitude_Differentielle : array [1..4] of double ;  //SE correction défaut d'offset des 4 voies // valeur en Volt
      end;



function _SetPortClose(hHandle: THandle): LongInt cdecl  ;
function _SetPortOpen(strDeviceName: WideString): THandle cdecl  ;
function _DefineUSB  (hHandle: THandle): LongInt cdecl  ;
function _GetVersion(hHandle: THandle;var strVersion: char): LongInt cdecl ;
function _GetUSBData(hHandle: THandle;var pTransfer: DATA_GTI;
                    var pTransfer2: DATA_ACQUISITION): LongInt cdecl ;
function _LanceAcqui(hHandle: THandle;var pTransfer: DATA_ACQUISITION): LongInt cdecl;
function _StopAcqui(hHandle: THandle): LongInt cdecl ;
function _LanceTHREAD(hHandle: THandle): LongInt cdecl;
function _StopTHREAD: LongInt cdecl ; //en fait procedure function void en C ?
function _IsRunTHREAD: LongInt cdecl ;
function _EmptyBuffer: LongInt cdecl ;
procedure _SendH8(var pBuffer: Byte; LenBuffer: LongInt) cdecl ;
function _GetH8(var BufferSend: Byte; LenBuffer: LongInt;UNICODE: BYTE): LongInt cdecl;
function _GetLenH8: LongInt cdecl;
function _StopAcquiLENTE: LongInt  cdecl;//en fait procedure function void en C ?
function _GetPipe(hHandle: THandle;Buffer1: PChar;LenSend: LongInt;Canal: LongInt): LongInt cdecl;
function _SendPipe(hHandle: THandle;Buffer1: PChar;LenSend: LongInt;Canal: LongInt): LongInt cdecl;
function _LanceGenerateur(hHandle: THandle;Loop: Byte;Generateur: PDATA_GENERATEUR): LongInt cdecl ;
function _StopGenerateur(hHandle: THandle): LongInt cdecl ;
function CreationTableaux : word;
function InitInstrument (wAdress : word ) : word;
function LanceGenerateur : word;
function SetFuncGenSignalType ( wSignalType : word ) : word ;
function SetFuncGenAmplitude ( dAmplitude : double ) : word;
function SetFuncGenDCOffset ( dDCOffset : double ) : word;
function SetFuncGenSymmetry ( dSymmetry: double ) : word;
function SetFuncGenFrequency (dFrequency: pdouble ) : word;
function GetFuncGenFrequency ( dFrequency : pdouble ): word ;
function SetFuncGenOutputOn ( wValue: word ) : word;
function SetCh1InputOn ( wValue : word ) : word ;
function SetCh2InputOn ( wValue : word ) : word ;
function SetCh3InputOn ( wValue : word ) : word ;
function SetCh4InputOn ( wValue : word ) : word ;
function GetCh1InputOn : word ;
function GetCh2InputOn : word ;
function GetCh3InputOn : word ;
function GetCh4InputOn : word ;
function SetCh1DiffOn ( wValue : word ) : word ;
function SetCh2DiffOn ( wValue : word ) : word ;
function SetCh3DiffOn ( wValue : word ) : word ;
function SetCh4DiffOn ( wValue : word ) : word ;
function GetCh1DiffOn : word ;
function GetCh2DiffOn : word ;
function GetCh3DiffOn : word ;
function GetCh4DiffOn : word ;
function SetMeasureMode ( ByMode : byte ) : word ;
function ADC_Abort : word ;
function StartMeasurement : word ;
function GetMeasurementRaw( wCh1 : PTWArray;wCh2: PTWArray) : word ;
function GetMeasurement (dCh1 : PDArray;dCh2: PDArray): word;
function SetRecordLength (dTotal : dword) : word ;
function SetPostSamples (dPost : dword) : word ;
function GetMaxSampleFrequency : dword ;
function GetMaxRecordLength : dword ;
function GetRecordLength : dword ;
function getSampleFrequency : dword ;
function GetAvailableSensitivities(dSensitivities :pTab20double): word;
function GetSensitivity ( byCh : byte;dSens: PDouble ) : word ;
function SetSensitivity ( byCh : byte; dSens : PDouble ): word  ;
function SetCoupling ( byCh  : byte;byMode : byte ): word ;
function SetTriggerSource( bysource    : byte ):word;
function SetTriggerHys ( byCh : byte;    dHysteresis : double) :word;
function setTriggerTimeOUT ( lTimeout    : dword ) : word;
function SetSampleFrequency( dFrequency       : Pdword  ) : word;
function SetTriggerLevel( byCh : byte;    dLevel  : double ) : word;
function SetTriggerMode ( byMode      : Byte ) : word;
function GetTriggerSource( bySource    : pbyte ) : word;

function SetTriggerPreTrig ( byMode      : Byte ) : word;


function GetFuncGenOutputOn ( wValue      : pword  ) : word;
function FillFuncGenMemory ( dwNrSamples : dword;   FuncGenData :  PTWArray2  ) : word;
function SetAutoRanging ( byCh        : byte;    byMode      : byte  ) : word;
function GetCoupling ( byCh        : byte;    byMode      : Pbyte  ) : word;
function GetMeasureMode ( byMode      : Pbyte  ) : word;
function GetPostSamples : word;
function GetTriggerMode ( byMode      : pByte  ) : word;
function GetTriggerTimeout : word;

function StartMeasurementfrancois : word ;
function GetMeasurementRawfrancois( wCh1 : PTWArray;wCh2: PTWArray) : word ;
function GetMeasurementfrancois (dCh1 : PDArray;dCh2: PDArray): word;

function GetMeasurementRawFrancoisTraceur_RAM( wCh1 : PTWArray;wCh2: PTWArray) : word ;
function GetMeasurementFrancoisTraceur_RAM (dCh1 : PDArray;dCh2: PDArray): word;

procedure RetrieveAllProcAddresses;
procedure NilAllProcAddresses;
procedure Exitinstrument;

function GetSampleFrequencyPossible( dFrequency       : Pdword  ) : dword;

{$ENDIF // !defined(AFX_GTICOMMX_H__0F384D80_6AF9_11DA_A5B7_000244639032__INCLUDED_)}

var   Gen        : TGenerateur;
      Acq        : TAcquisition;
      GTIhandle  : Thandle ;
      Ch1DoubleArray            : DArray;
      Ch2DoubleArray            : DArray;
      Ch3DoubleArray            : DArray;
      Ch4DoubleArray            : DArray;
      Ch1WordArray              : TWArray;
      Ch2WordArray              : TWArray;
      Ch3WordArray              : TWArray;
      Ch4WordArray              : TWArray;
      FuncGenArray              : TWArray2;
      enveloppe                 : DArray;
      DataAcq   : DATA_ACQUISITION ;
      DataGTI   : DATA_GTI ;
      DataGene  : DATA_GENERATEUR;
      DllHandle                 : THandle; // a supprimer a terme ?
      NbFrequences : integer;                    // Nb Frequences avec doublons
      //Frequence  : array [0 .. 100000] of double;  // tableau des frequences non triées et avec doublons
      NbreData   : array [0 .. 100000] of word;   // tableau  non trié et avec doublons
      BasedeTemps: array [0 .. 100000] of byte;   // tableau  non trié et avec doublons
      Reload     : array [0 .. 100000] of word;   // tableau  non trié et avec doublons
      UnSurN     : array [0 .. 100000] of longint; // tableau  non trié et avec doublons
      AcquisitionEnCours : boolean ; // pour le startmeasurement.

      DataUsbTRACEUR: integer;           //compteur de pts acqui en mode traceur
      cptTRACEUR    : integer;
      

implementation

uses  UnitfrequencesGBF,UnitFrequencesAcqu,UnitFrequencesGBFfichier;



function DoEvents; external 'GTICOMMX.DLL';
//function GtiCommX; external 'GTICOMMX.DLL';
//function ~GtiCommX; external 'GTICOMMX.DLL';
function _SetPortClose; external 'GTICOMMX.DLL';
function _SetPortOpen; external 'GTICOMMX.DLL';
function _DefineUSB;external 'GTICOMMX.DLL';
function _GetVersion; external 'GTICOMMX.DLL';
function _GetUSBData; external 'GTICOMMX.DLL';
function _LanceAcqui; external 'GTICOMMX.DLL';
function _StopAcqui; external 'GTICOMMX.DLL';
function _LanceTHREAD; external 'GTICOMMX.DLL';
function _StopTHREAD; external 'GTICOMMX.DLL';
function _IsRunTHREAD; external 'GTICOMMX.DLL';
function _EmptyBuffer; external 'GTICOMMX.DLL';
procedure _SendH8; external 'GTICOMMX.DLL';
function _GetH8; external 'GTICOMMX.DLL';
function _GetLenH8; external 'GTICOMMX.DLL';
function _StopAcquiLENTE; external 'GTICOMMX.DLL';
function _GetPipe; external 'GTICOMMX.DLL';
function _SendPipe; external 'GTICOMMX.DLL';
function _LanceGenerateur; external 'GTICOMMX.DLL';
function _StopGenerateur; external 'GTICOMMX.DLL';
//*********************************************************************************************
// fonctions
function   FreqToInd ( freq : double ):integer;
var decade : integer;
begin
//chaque décade utilise 100000 cases
// 10000 inutilisées et 900000 points
// 5 chiffres significatifs
// 1ère décade = 1 , 10  Hz
// décades inférieures sont dans des 10000 premiers points ( inutilisés) de la première décade et donc moins de chiffres significatifs.

 decade := trunc (ln(freq)/ln(10)) ;
 if decade < 0  then decade := 0 ;
FreqToInd := 10000 * decade + round ( 1000 * freq / exp ( ln(10) * decade )  );
end;

function IndToFreq ( ind : integer) : double;
begin
  IndToFreq := exp ( (ind div 10000) * ln (10) ) * (ind mod 10000 )/1000 ;
end;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
function CreationTableaux : word;
var   i,j,cpt,indice,puissance : integer ;
      Freq,Freq1,Freq0 : double;
      NbFrequences : integer;                    // Nb Frequences avec doublons
      DataAcq : DATA_ACQUISITION ;
      fichier                : textfile;         //MERLE essai tableau de fréquences

const ResolutionGeneMin = 24 ;
      ResolutionGeneMax = 2000 ;
      ResolutionGeneIdealeMin = 512 ;
      ResolutionGeneIdealeMax = 1024 ; //inutile

begin

//----------------------------------------------------
// Construction du tableau de fréquences du Générateur

// initialisation
  for i := 0 to 100000 - 1 do
  begin
    NbreData    [i] := 0 ;
    BasedeTemps [i] := 0 ;
   Reload      [i] := 65535 ; // servira de test pour savoir si une freq est possible
  end;

// construction
 { cpt := 0 ;
  puissance := 1 ;
  for i := 0 to 5 do
  begin
    for j := 0 to 89999 do
    begin
      Frequence[cpt] := puissance + puissance * j / 10000 ;
      cpt := cpt + 1 ;
    end;
    puissance := puissance * 10 ;
  end;
  }

 // Base de temps = 1 Fech = 12 MHz
   for i := ResolutionGeneMin to ResolutionGeneMax do
     for j := 0 to 65535 do   //reload
     begin
       Freq := 12E6 /  ( i * (65536-j) );
       Indice := FreqToInd ( Freq ) ;
       NbreData    [indice] := i ;
         BasedeTemps [indice] := 1 ;
         Reload      [indice] := j ;
     end;

   // Base de temps = 0 Fech = 48 MHz
   for i := ResolutionGeneMin to ResolutionGeneMax do
   begin
   Freq := 48E6 / i ;
   indice := FreqToInd(Freq);
    if ( NbreData[Indice] = 0 )  then  // si nouvelle freq
       begin
         NbreData    [indice] := i ;
         BasedeTemps [indice] := 0 ;
         Reload      [indice] := 65535 ;
       end
       else  // freq exist mais nouvelle config mieux
       begin
         if (  NbreData[Indice] < ResolutionGeneIdealeMin )  // si < ResolutionGeneIdealeMin on garde le plus grand
             and ( NbreData[Indice] < i )  then
         begin
           NbreData    [indice] := i ;
           BasedeTemps [indice] := 0 ;
           Reload      [indice] := 65535 ;
         end;
         if (  NbreData[Indice] > ResolutionGeneIdealeMin )  // si < ResolutionGeneIdealeMin on garde le plus grand
             and ( NbreData[Indice] > i )
             and ( i > ResolutionGeneIdealeMin) then
         begin
           NbreData    [indice] := i ;
           BasedeTemps [indice] := 0 ;
           Reload      [indice] := 65535 ;
         end;
       end;
   end;

   // Base de temps = 2 Fech = 3 MHz

   // a faire  ?? pas indispensable pour le moment


  // transfert des fréquences vers le tableau final.

  assignfile(fichier,'c:\frequenceGBF.txt');
  rewrite(fichier);

  cpt := 0;
  for i := 0 to 100000 - 1 do
  begin
    if NbreData[i] > 0 then
    begin
      Gen.Frequence   [cpt] := IndToFreq (i) ;
      Gen.NbreData    [cpt] := NbreData    [i] ;
      Gen.BasedeTemps [cpt] := BasedeTemps [i] ;
      Gen.Reload      [cpt] := Reload      [i] ;

      writeln(fichier,'Gen.Frequence   [' , cpt ,'] :=' , Gen.Frequence   [cpt],';');
      writeln(fichier,'Gen.NbreData [',cpt,'] :=',Gen.NbreData [cpt],';');
      writeln(fichier,'Gen.BasedeTemps [',cpt,'] :=',Gen.BasedeTemps [cpt],';');
      writeln(fichier,'Gen.Reload      [',cpt,'] :=',Gen.Reload      [cpt],';' );



      cpt := cpt + 1 ;
    end;
  end;

closefile(fichier);

Gen.NbFrequences := cpt ;


 {   METHODE TROP LOURDE >2Go:
//----------------------------------------------------
// Construction du tableau de fréquences du Générateur
 cpt := 0 ;
   // Base de temps = 0 Fech = 48 MHz
   for i := ResolutionGeneMin to ResolutionGeneMax do
   begin
   Frequence   [cpt] := 48E6 / i ;
   NbreData    [cpt] := i ;
   BasedeTemps [cpt] := 0 ;
   Reload      [cpt] := 65535 ;
   cpt := cpt + 1 ;
   end;

   // Base de temps = 1 Fech = 12 MHz
   for i := ResolutionGeneMin to ResolutionGeneMax do
     for j := 0 to 65535 do   //reload
     begin
       Frequence   [cpt] := 48E6 /  ( i * (65536-j) );
       NbreData    [cpt] := i ;
       BasedeTemps [cpt] := 1 ;
       Reload      [cpt] := j ;
       cpt := cpt + 1 ;
     end;
   // Base de temps = 2 Fech = 3 MHz

   // a faire<!

   NbFrequences := cpt + 1 ;

   //------------------------------------------
   //  Suppression doublons Fréquences et Tri

   Freq0 := 0 ; // freq précédement écrite
   cpt   := 0 ;
   repeat
     Freq1:= 100E6; //valeur supérieure F max possible
     indice := 0 ;

   // recherches des freqs identiques et choix meilleure config selon le
   //critère = le plus petit nb points avec un minimum de ResolutionGeneIdealeMin
     for i := 0 to NbFrequences - 1 do
     begin
     
       if (frequence[i] = freq0) and (i>0) then  //si une config donne la meme frequence
       begin
         if (  Gen.NbreData[cpt-1] < ResolutionGeneIdealeMin )  // si < ResolutionGeneIdealeMin on garde le plus grand
             and ( NbreData[i] > Gen.NbreData[cpt-1] )  then
         begin
           Gen.Frequence   [cpt-1] := Frequence   [i] ;  //remplacement
           Gen.NbreData    [cpt-1] := NbreData    [i] ;
           Gen.BasedeTemps [cpt-1] := BasedeTemps [i] ;
           Gen.Reload      [cpt-1] := Reload      [i] ;
         end;
         if (  Gen.NbreData[cpt-1] > ResolutionGeneIdealeMin )
             and ( NbreData[i] > ResolutionGeneIdealeMin )  // si > ResolutionGeneIdealeMin on garde le plus petit
             and ( NbreData[i] < Gen.NbreData[cpt-1] )  then
         begin
           Gen.Frequence   [cpt-1] := Frequence   [i] ;  //remplacement
           Gen.NbreData    [cpt-1] := NbreData    [i] ;
           Gen.BasedeTemps [cpt-1] := BasedeTemps [i] ;
           Gen.Reload      [cpt-1] := Reload      [i] ;
         end;
       end;
     end;
   // TRI
   // recherche freq la plus petite mais au dessus de la fréq précédente
   for i := 0 to NbFrequences - 1 do
   begin
     if (Frequence[i] > Freq0) and (Frequence[i] < Freq1) then
     begin
       Freq1 := Frequence[i] ;
       indice := i ;
     end;
   end;
   // Stockage dans les tableaux finaux
   Gen.Frequence   [cpt] := Frequence   [indice] ;
   Gen.NbreData    [cpt] := NbreData    [indice] ;
   Gen.BasedeTemps [cpt] := BasedeTemps [indice] ;
   Gen.Reload      [cpt] := Reload      [indice] ;
   cpt := cpt + 1 ;
   Freq0 := Freq1;
   until Freq1=100E6;
 Gen.NbFrequences := cpt ;}

//---------------------------------------------------
// tableau de frequences d'echantillonnage pour le mode fichier du gbf

// initialisation
  for i := 0 to 100000 - 1 do
  begin
   BasedeTemps [i] := 255 ;
   Reload      [i] := 65535 ; // servira de test pour savoir si une freq est possible
  end;
  // Base de temps = 0 Fech = 48 MHz

   Freq := 48E6 ;
   indice := FreqToInd(Freq);
   BasedeTemps [indice] := 0 ;
   Reload      [indice] := 65535 ;

 // Base de temps = 1 Fech = 12 MHz
   for j := 0 to 65535 do   //reload
     begin
       Freq := 12E6 /  ( 65536-j );
       Indice := FreqToInd ( Freq ) ;
       BasedeTemps [indice] := 1 ;
       Reload      [indice] := j ;
     end;

    // Base de temps = 1 Fech = 12 MHz
    // les valeurs identiques sont tout simplement ecrasées
   for j := 0 to 65535 do   //reload
     begin
       Freq := 4E6 /  ( 65536-j );
       Indice := FreqToInd ( Freq ) ;
       BasedeTemps [indice] := 2 ;
       Reload      [indice] := j ;
     end;

  // transfert des fréquences vers le tableau final.

  assignfile(fichier,'c:\frequenceEchGBF.txt');
  rewrite(fichier);


  cpt := 0;
  for i := 0 to 100000 - 1 do
  begin
    if BasedeTemps[i] <> 255 then
    begin
      Gen.Fichier.Frequence   [cpt] := IndToFreq (i) ;
      Gen.Fichier.BasedeTemps [cpt] := BasedeTemps [i] ;
      Gen.Fichier.Reload      [cpt] := Reload      [i] ;

      writeln(fichier,'Gen.Fichier.Frequence   [' , cpt ,'] :=' , Gen.Fichier.Frequence   [cpt],';');
      writeln(fichier,'Gen.Fichier.BasedeTemps [',cpt,'] :=',Gen.Fichier.BasedeTemps [cpt],';');
      writeln(fichier,'Gen.Fichier.Reload      [',cpt,'] :=',Gen.Fichier.Reload      [cpt],';' );

      cpt := cpt + 1 ;
    end;
  end;

closefile(fichier);


Gen.NbFrequences := cpt ;


//---------------------------------------------------
// tableau de frequences d'echantillonnage pour le mode acquisition

// initialisation
  for i := 0 to 100000 - 1 do
  begin
   BasedeTemps [i] := 255   ;  
   Reload      [i] := 65535 ;
   UnSurN      [i] := 0     ;  // servira de test pour savoir si une freq est possible
  end;


   // UnSurN  Fech = 10 kHz / UnSurN
    j := 56;  //reload
     for i := 1 to 10000 - 1 do  // UnSurN
     begin
       Freq := round (( 2E6 / ( (256-j)*i ) ));
       Indice := FreqToInd ( Freq ) ;
       BasedeTemps [indice] := 1 ;
       Reload      [indice] := j ;
       UnSurN      [indice] := i ;
     end;

  // Base de temps = 2 , Fech = 10 MHz , reload impossible


       Freq := round (( 10E6  ));
       Indice := FreqToInd ( Freq ) ;
       BasedeTemps [indice] := 2 ;
       Reload      [indice] := 255 ;
       UnSurN      [indice] := 1 ;


  // Base de temps = 0 Fech = 6 MHz
  // les valeurs identiques sont tout simplement ecrasées
   for j := 0 to 255 do   //reload
     begin
       Freq := round (( 6E6 /  ( 256-j ) ));
       Indice := FreqToInd ( Freq ) ;
       BasedeTemps [indice] := 0 ;
       Reload      [indice] := j ;
       UnSurN      [indice] := 1 ;
     end;

 // Base de temps = 1 Fech = 2 MHz
   // les valeurs identiques sont tout simplement ecrasées
   for j := 0 to 255 do   //reload
     begin
       Freq :=  round (( 2E6 /  ( 256-j ) ));
       Indice := FreqToInd ( Freq ) ;
       BasedeTemps [indice] := 1 ;
       Reload      [indice] := j ;
       UnSurN      [indice] := 1 ;
     end;

  



  // transfert des fréquences vers le tableau final.

  assignfile(fichier,'c:\frequencesechantillonnage.txt');

  rewrite(fichier);


  cpt := 0;
  for i := 0 to 100000 - 1 do
  begin
    if UnSurN[i] <> 0 then
    begin
      Acq.Frequence   [cpt] := round (( IndToFreq (i) )) ;
      Acq.BasedeTemps [cpt] := BasedeTemps [i] ;
      Acq.Reload      [cpt] := Reload      [i] ;
      Acq.UnSurN      [cpt] := UnSurN      [i] ;



      writeln(fichier,'Acq.Frequence   [' , cpt ,'] :=' , Acq.Frequence   [cpt],';');
      writeln(fichier,'Acq.BasedeTemps [',cpt,'] :=',Acq.BasedeTemps [cpt],';');
      writeln(fichier,'Acq.Reload      [',cpt,'] :=',Acq.Reload      [cpt],';' );
      writeln(fichier,'Acq.UnSurN      [',cpt,'] :=',Acq.UnSurN      [cpt],';');




      cpt := cpt + 1 ;
    end;
  end;


  closefile(fichier);


Acq.NbFrequences := cpt ;

//////

end;

////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

function InitInstrument (wAdress : word ) : word;
var   i,j,cpt,indice,puissance : integer ;
      Freq,Freq1,Freq0 : double;
      NbFrequences : integer;                    // Nb Frequences avec doublons
      DataAcq : DATA_ACQUISITION ;
      Ini: TIniFile;

const ResolutionGeneMin = 24 ;
      ResolutionGeneMax = 2000 ;
      ResolutionGeneIdealeMin = 512 ;
      ResolutionGeneIdealeMax = 1024 ; //inutile ??

begin
GTIHandle := _SetPortOpen('OrphyGTI2-0');
if GTIhandle<>0 then
begin
  InitInstrument := E_NO_ERRORS;  // appareil présent
//----------------------------------------------------
// "Construction du tableau de fréquences du Générateur"
// CHARGEMENT des fréquences DS le tableau .

  ChargementValeurFrqGBF;


//---------------------------------------------------
// "tableau de frequences d'echantillonnage pour le mode fichier du gbf"
// CHARGEMENT des fréquences DS le tableau .

  ChargementValeurFrqGBFfichier;


//---------------------------------------------------
// "tableau de frequences d'echantillonnage pour le mode acquisition"
// CHARGEMENT des fréquences DS le tableau .

 // ChargementTableauFreqAcq;
  chargementTableauFreqAcq;
  

//////

//----------------------------------------------------
// Paramètres Acquisition par défaut

Acq.RecordLength := GetMaxRecordLength;
DataAcq.Calibrage:=1;
DataAcq.Voie[0].On:=1;
DataAcq.Voie[1].On:=1;
DataAcq.Voie[2].On:=1;
DataAcq.Voie[3].On:=1;
{
DataAcq.Voie[0].&On:=1;
DataAcq.Voie[1].&On:=1;
DataAcq.Voie[2].&On:=1;
DataAcq.Voie[3].&On:=1;
}

DataAcq.Voie[0].Calibre:=0;
DataAcq.Voie[1].Calibre:=0;
DataAcq.Voie[2].Calibre:=0;
DataAcq.Voie[3].Calibre:=0;
DataAcq.Voie[0].Differentiel:=0;
DataAcq.Voie[1].Differentiel:=0;
DataAcq.Voie[2].Differentiel:=0;
DataAcq.Voie[3].Differentiel:=0;
DataAcq.Trig.TrigOn:=1;
DataAcq.Trig.PreTrigOn:=1;
DataAcq.Trig.FrontMontant:=1;
DataAcq.Trig.Valeur:=000;
Freq := 500*256;
SetSampleFrequency( @Freq );
Acq.RecordLength := 256;
Acq.TriggerTimeOut := 1000;

// Paramètres Gene fichier par défaut sin 1 kHz 1 V centré
Gen.TypeSignal := lstarbitrary ; // pour que SetFuncGenFrequency marche
Gen.Fichier.NbreData := 1000;
freq := 1000* Gen.Fichier.NbreData ;
SetFuncGenFrequency (@freq);
for i := 0 to Gen.Fichier.NbreData  - 1 do
      begin
        Gen.Fichier.BufferOut [i] :=  round (( 32767
        + 32767  * sin ( 6.283 * i / Gen.Fichier.NbreData )  ));
      end;


// Paramètres Gene par défaut sin 1 kHz 1 V centré

Gen.TypeSignal := lstSine ;
Gen.Amplitude  := 5 ;
Gen.Offset     := 0 ;
Gen.Symetrie   := 50;
Gen.Allume     := 0 ;
Gen.Multicoup  := 1 ;
 end
 else
 begin
 InitInstrument:=E_NO_HARDWARE ; // pas d'appareil
 end;

//SE Correction des défauts d'offset du GBF et de l'acquisition
// désactivé pour l'instant
 Gen.Correction_Amplitude := 0 ;
 for i := 1 to 4 do
begin
Acq.Correction_Amplitude_Unipolaire [i] := 0 ;
Acq.Correction_Amplitude_Differentielle[i] := 0 ;
end;


{Ini := TIniFile.Create( ExtractFilePath(Application.ExeName)+'EtalonnageGTI2.INI'  );
  try

   for i := 1 to 4 do
     begin
     Acq.Correction_Amplitude_Unipolaire[i]     := Ini.ReadFloat( 'GTINumeroXXX', 'CorrectionVoie'+inttostr(i)+'Unipolaire'   , 0 );
     Acq.Correction_Amplitude_Differentielle[i] := Ini.ReadFloat( 'GTINumeroXXX', 'CorrectionVoie'+inttostr(i)+'Differentiel' , 0 );

     end;
   finally
    Ini.free;
  end; }



end;

///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////

procedure Exitinstrument;
begin
  _SetPortClose(GTIHandle);
end;

procedure  RetrieveAllProcAddresses;
begin
  //a ne pas faire !!
end;

procedure  NilAllProcAddresses;
begin
  //a ne pas faire !!
end;

//**********************************************************************
//   géné

function LanceGenerateur : word;
var i,IndiceSymetrie     : integer;
    Correction_Numerique : longint; //SE défaut d'offset converti en numérique
begin
{ 0 : sinus  1 : triangle  2 : Carré  3 : DC  4 : bruit  5 : signal arbitraire
symétrie <>50% non géré en sinus
a faire : fournir valeur exacte pour pi, symétrie

pb : a quel valeur correspond le O V? rep : en developpement hard chez mecacel }


  if Gen.allume = 1 then
  begin
    if Gen.Amplitude > 10 then
      Gen.Amplitude := 10;
    if Gen.Amplitude < - 10 then
      Gen.Amplitude := - 10;
  // si pb offset+amp>10 priorité amplitude
  if (Gen.Offset + Gen.Amplitude) > 10  then
    Gen.Offset := 10 - Gen.Amplitude ;
  if (Gen.Offset - Gen.Amplitude) < - 10  then
    Gen.Offset := -10 + Gen.Amplitude ;
  // transfert structure delphi vers structure gti
  DataGene.NbreData    := Gen.NbreData[Gen.IndiceFrequence] ;
  DataGene.BaseDeTemps := Gen.BaseDeTemps[Gen.IndiceFrequence] ;
  DataGene.Reload      := Gen.Reload[Gen.IndiceFrequence] ;

  //  Indice de symétrie
  IndiceSymetrie:=round((Gen.NbreData[Gen.IndiceFrequence]-1)*Gen.Symetrie/100);

  case Gen.TypeSignal of  //----------------------------------------------
    0: // sinus
      for i := 0 to DataGene.NbreData  - 1 do
      begin
        DataGene.BufferOut [i] :=  round (( 7644 {valeur du 0 V}
        + 7644 * ( - Gen.Correction_Amplitude - Gen.Offset -  Gen.Amplitude * sin ( 6.283 * i / DataGene.NbreData )  ) / 10 ));
      end;
   {
   1: // triangle sans symétrie;
   begin
      for i := 0 to round((DataGene.NbreData  - 1) / 2) do
      begin
        DataGene.BufferOut [i] :=  round (( 7644
        + 7644 * ( - Gen.Correction_Amplitude - Gen.Offset -  Gen.Amplitude *  ( 4 * i / DataGene.NbreData - 1   ) ) / 10 ));
      end;
      for i := round((DataGene.NbreData  - 1) / 2)  to DataGene.NbreData  - 1 do
      begin
        DataGene.BufferOut [i] :=  round (( 7644
        + 7644 * ( - Gen.Correction_Amplitude - Gen.Offset -  Gen.Amplitude *  ( 3 -  4 * i / DataGene.NbreData   ) ) / 10 ));
      end;
   end;
   }
   1: // triangle   avec la symétrie   : marche pas
   begin
      for i := 0 to IndiceSymetrie do
      begin
        DataGene.BufferOut [i] :=  round (( 7644 {valeur du 0 V}
        + 7644 * ( - Gen.Correction_Amplitude - Gen.Offset -  Gen.Amplitude *  ( 4 * i / DataGene.NbreData - 1   ) ) / 10 ));
      end;
      for i := IndiceSymetrie  to DataGene.NbreData  - 1 do
      begin
        DataGene.BufferOut [i] :=  round (( 7644  {valeur du 0 V}
        + 7644 * ( - Gen.Correction_Amplitude - Gen.Offset -  Gen.Amplitude *  ( 3 -  4 * i / DataGene.NbreData   ) ) / 10 ));
      end;
   end;


   {
   2: // carré sans symétrie
      for i := 0 to DataGene.NbreData  - 1 do
      begin
        if i > DataGene.NbreData/2 then
        DataGene.BufferOut [i] :=  round (( 7644
        + 7644 * ( - Gen.Correction_Amplitude - Gen.Offset -  Gen.Amplitude *  ( 1 ) ) / 10 ))
        else
        DataGene.BufferOut [i] :=  round (( 7644
        + 7644 * ( - Gen.Correction_Amplitude - Gen.Offset -  Gen.Amplitude *  ( -1 ) ) / 10 ));
      end;
   }
   2: // carré avec la symétrie
      for i := 0 to DataGene.NbreData  - 1 do
      begin
        if i > IndiceSymetrie then
        DataGene.BufferOut [i] :=  round (( 7644 {valeur du 0 V}
        + 7644 * ( - Gen.Correction_Amplitude - Gen.Offset -  Gen.Amplitude *  ( 1 ) ) / 10 ))
        else
        DataGene.BufferOut [i] :=  round (( 7644  {valeur du 0 V}
        + 7644 * ( - Gen.Correction_Amplitude - Gen.Offset -  Gen.Amplitude *  ( -1 ) ) / 10 ));
      end;

   3: // DC;
       for i := 0 to DataGene.NbreData  - 1 do
      begin
        DataGene.BufferOut [i] :=  round (( 7644 {valeur du 0 V}
        + 7644 * ( - Gen.Correction_Amplitude - Gen.Offset -  Gen.Amplitude ) / 10 ))
      end;
   4:; //bruit a faire ???;
   5:// fichier
     begin
     // correction du défaut d'offset du GBF
     Correction_Numerique := round ( 7644 * ( - Gen.Correction_Amplitude ) /10 ) ;
       DataGene.NbreData := Gen.Fichier.NbreData;
       DataGene.BaseDeTemps := Gen.Fichier.BaseDeTemps[Gen.Fichier.IndiceFrequence] ;
       DataGene.Reload      := Gen.Fichier.Reload[Gen.Fichier.IndiceFrequence] ;
       for i := 0 to DataGene.NbreData  - 1 do
       begin    // 16 bits vers 14 bits changement echelle 0 65535 vers 16384 0  + correction du défaut d'offset du GBF
         DataGene.BufferOut [i] := round ( 7644 + Correction_Numerique + 7644 * Gen.Amplitude * ( Gen.Fichier.BufferOut [i] - 32767) / ( 32767 * 10 ) );
       end;
     end; 

   end; // case
  if _LanceGenerateur(GTIHandle,Gen.Multicoup,@DataGene ) = 0 then
    LanceGenerateur := E_NO_ERRORS
  else
    LanceGenerateur := E_NO_GENERATOR ;

  end
  else  // if Gen.allume = 1
    if _StopGenerateur(GTIHandle)= 1 then
      LanceGenerateur := E_NO_ERRORS
    else
      LanceGenerateur := E_NO_GENERATOR ;

end;

function SetFuncGenSignalType ( wSignalType : word ) : word ;
begin
  {lstSine = 0; lstTriangle= 1; lstSquare = 2; lstDC= 3; lstNoise = 4; lstarbitrary  = 5;  }
  Gen.TypeSignal := wSignalType ;
  SetFuncGenSignalType := LanceGenerateur;
end;

function SetFuncGenAmplitude ( dAmplitude : double ) : word;
begin      //14 bits 16384
  if ( dAmplitude >= -10 ) and ( dAmplitude <= 10 )then
  begin
   Gen.Amplitude := dAmplitude ;
   SetFuncGenAmplitude := LanceGenerateur;
  end
  else
    SetFuncGenAmplitude := E_INVALID_VALUE ;
end;

function SetFuncGenDCOffset ( dDCOffset : double ) : word;
begin
  Gen.Offset := dDCOffset;
  SetFuncGenDCOffset := LanceGenerateur;
end;

function SetFuncGenSymmetry ( dSymmetry: double ) : word;
begin
  Gen.Symetrie := dSymmetry;
  SetFuncGenSymmetry := LanceGenerateur;
end;

function SetFuncGenFrequency (dFrequency: pdouble ) : word;
var cpt : integer;
begin
  if Gen.TypeSignal <> lstarbitrary then  // Mode fichier
  begin
    // mode normal
    if dFrequency^ < Gen.Frequence[Gen.NbFrequences - 1] then
    begin
    cpt := 0 ;
    // recherche de la frequence la plus proche
    repeat
      cpt := cpt + 1 ;
    until dFrequency^ <= Gen.Frequence[cpt];
    // choix entre les 2 fréquences les plus proches
    if (cpt >0) and (Gen.Frequence[cpt]-dFrequency^ > dFrequency^-Gen.Frequence[cpt-1]) then
      cpt := cpt - 1 ;
    end
    else
      cpt := Gen.NbFrequences - 1 ; // freq = 2 MHz

    dFrequency^ := Gen.Frequence[cpt] ;//renvoi frequence réelle
    Gen.IndiceFrequence := cpt ;
  end
  else
  begin
    // idem pour mode fichier
    if dFrequency^ < Gen.Fichier.Frequence[Gen.Fichier.NbFrequences - 1] then
    begin
      cpt := 0 ;
      // recherche de la frequence la plus proche
      repeat
        cpt := cpt + 1 ;
      until dFrequency^ <= Gen.Fichier.Frequence[cpt];
      // choix entre les 2 fréquences les plus proches
      if (cpt >0) and (Gen.Fichier.Frequence[cpt]-dFrequency^ > dFrequency^-Gen.Fichier.Frequence[cpt-1]) then
        cpt := cpt - 1 ;
    end
    else
      cpt := Gen.Fichier.NbFrequences - 1 ; // freq = 48 MHz

    dFrequency^ := Gen.Fichier.Frequence[cpt] ;//renvoi frequence réelle
    Gen.Fichier.IndiceFrequence := cpt ;
  end;
  // maintenant c'est parti
  SetFuncGenFrequency := LanceGenerateur;
end;

function GetFuncGenFrequency ( dFrequency : pdouble ): word ;
begin
// mode fichier a faire
  dFrequency^ := Gen.Frequence[Gen.IndiceFrequence];
  GetFuncGenFrequency := E_NO_ERRORS;
end;

function SetFuncGenOutputOn ( wValue: word ) : word;
begin
  Gen.allume := wValue ;
  SetFuncGenOutputOn := LanceGenerateur;
end;

function GetFuncGenOutputOn ( wValue      : pword  ) : word;
begin
GetFuncGenOutputOn := E_NO_ERRORS ;
  case Gen.Allume of
    0 : wValue^ := 0 ;
    1 : wValue^ := 1 ;
  else
    GetFuncGenOutputOn := E_INVALID_VALUE ;
  end;

end;

function FillFuncGenMemory ( dwNrSamples : dword;   FuncGenData : PTWArray2  ) : word;
var i : integer;
begin
  if dwNrSamples>16000 then
  begin
    FillFuncGenMemory := E_INVALID_VALUE ;
  end
  else
  begin
    Gen.Fichier.NbreData := dwNrSamples ;
    for i := 0 to dwNrSamples - 1 do
      Gen.Fichier.BufferOut[i] := FuncGenData^[i] ;
    FillFuncGenMemory := E_NO_ERRORS ;
  end;
  
end;

//**********************************************************************
// acquisition

function SetCh1InputOn ( wValue : word ) : word ;
begin
SetCh1InputOn := E_NO_ERRORS ;
case wValue of
 0 : DataAcq.Voie[0].On:= 0;
 1 : DataAcq.Voie[0].On:= 1;
 else
 SetCh1InputOn := E_INVALID_VALUE ;
 end;
end;
function SetCh2InputOn ( wValue : word ) : word ;
begin
SetCh2InputOn := E_NO_ERRORS ;
case wValue of
 0 : DataAcq.Voie[1].On:= 0;
 1 : DataAcq.Voie[1].On:= 1;
 else
 SetCh2InputOn := E_INVALID_VALUE ;
 end;
end;
function SetCh3InputOn ( wValue : word ) : word ;
begin
SetCh3InputOn := E_NO_ERRORS ;
case wValue of
 0 : DataAcq.Voie[2].On:= 0;
 1 : DataAcq.Voie[2].On:= 1;
 else
 SetCh3InputOn := E_INVALID_VALUE ;
 end;
end;
function SetCh4InputOn ( wValue : word ) : word ;
begin
SetCh4InputOn := E_NO_ERRORS ;
case wValue of
 0 : DataAcq.Voie[3].On:= 0;
 1 : DataAcq.Voie[3].On:= 1;
 else
 SetCh4InputOn := E_INVALID_VALUE ;
 end;
end;

function GetCh1InputOn : word ;
begin
  GetCh1InputOn := DataAcq.Voie[0].On ;
end;
function GetCh2InputOn : word ;
begin
  GetCh2InputOn := DataAcq.Voie[1].On ;
end;
function GetCh3InputOn : word ;
begin
  GetCh3InputOn := DataAcq.Voie[2].On ;
end;
function GetCh4InputOn : word ;
begin
  GetCh4InputOn := DataAcq.Voie[3].On ;
end;


function SetCh1DiffOn ( wValue : word ) : word ;
begin
SetCh1DiffOn := E_NO_ERRORS ;
case wValue of
 0 : DataAcq.Voie[0].Differentiel:= 0;
 1 : DataAcq.Voie[0].Differentiel:= 1;
 else
 SetCh1DiffOn := E_INVALID_VALUE ;
 end;
end;
function SetCh2DiffOn ( wValue : word ) : word ;
begin
SetCh2DiffOn := E_NO_ERRORS ;
case wValue of
 0 : DataAcq.Voie[1].Differentiel:= 0;
 1 : DataAcq.Voie[1].Differentiel:= 1;
 else
 SetCh2DiffOn := E_INVALID_VALUE ;
 end;
end;
function SetCh3DiffOn ( wValue : word ) : word ;
begin
SetCh3DiffOn := E_NO_ERRORS ;
case wValue of
 0 : DataAcq.Voie[2].Differentiel:= 0;
 1 : DataAcq.Voie[2].Differentiel:= 1;
 else
 SetCh3DiffOn := E_INVALID_VALUE ;
 end;
end;
function SetCh4DiffOn ( wValue : word ) : word ;
begin
SetCh4DiffOn := E_NO_ERRORS ;
case wValue of
 0 : DataAcq.Voie[3].Differentiel:= 0;
 1 : DataAcq.Voie[3].Differentiel:= 1;
 else
 SetCh4DiffOn := E_INVALID_VALUE ;
 end;
end;

function GetCh1DiffOn : word ;
begin
  GetCh1DiffOn := DataAcq.Voie[0].Differentiel ;
end;
function GetCh2DiffOn : word ;
begin
  GetCh2DiffOn := DataAcq.Voie[1].Differentiel ;
end;
function GetCh3DiffOn : word ;
begin
  GetCh3DiffOn := DataAcq.Voie[2].Differentiel ;
end;
function GetCh4DiffOn : word ;
begin
  GetCh4DiffOn := DataAcq.Voie[3].Differentiel ;
end;



function StartMeasurement : word ;
var InstantInitial     : int64 ;
    SourceTrigger : byte ;
    Erreur        : word ;
    CompteurGetUSBData : integer ;

const SeuilUSBData = 0 ;   // normalement c'est zéro mais !!!
begin
// si trigger actif : on fournit le level de la voie triggeuse
  if DataAcq.Trig.TrigOn > 0 then
    DataAcq.Trig.Valeur :=  round (2048 +  2047 * Acq.TriggerLevel[ DataAcq.Trig.TrigOn] / 15 ) ;

InstantInitial := GetTickCount;
//DataAcq.Calibrage := 1 ;
//SetTriggerTimeOut(3000);


  // on lance une acquisition
    if _lanceacqui(GTIHandle, DataAcq ) = 0 then
    begin
    AcquisitionEnCours := True;
    //on attend l'arrivée des données jusqu'au time out arbitraire
      InstantInitial := GetTickCount; // CompteurGetUSBData := 0 ;
      repeat
        Acq.NbDataUSB :=_getusbdata(GTIHandle, DataGTI , DataAcq);
        // CompteurGetUSBData := CompteurGetUSBData + 1 ;  // garde fou
      until ((Acq.NbDataUSB > SeuilUSBData) or ( GetTickCount > ( InstantInitial + Acq.TriggerTimeOut )) ); // or ( CompteurGetUSBData > 1000 ));
    end
    else
      Erreur := E_NO_HARDWARE  ; // problème de _lanceacqui

  // On teste si l'acquisition s'est bien passée ou s'il n'y a pas eu de trigger

      if (Acq.NbDataUSB = 0) then // and  ( CompteurGetUSBData > 20 ) then //( GetTickCount > ( InstantTo + Acq.TriggerTimeOut ) ) then
        Erreur := E_NO_TRIGGER
      else
        Erreur := E_NO_ERRORS;

  // S'il n'y a pas eu de trigger, on lance une acquisition sans trigger.

  if  Erreur = E_NO_TRIGGER  then
  begin
   GetTriggerSource ( @SourceTrigger ) ; // On stocke le type de trigger
   SetTriggerSource ( ltsNoTrig ) ;      // Pas de trigger

   if _lanceacqui(GTIHandle, DataAcq ) = 0 then
    begin  // si la procédure est bien lancée
      //on attend l'arrivée des données jusqu'au time out arbitraire
      CompteurGetUSBData := 0 ;
      repeat
        Acq.NbDataUSB :=_getusbdata(GTIHandle, DataGTI , DataAcq);
        CompteurGetUSBData := CompteurGetUSBData + 1 ;  // garde fou
      until ((Acq.NbDataUSB > SeuilUSBData) or ( CompteurGetUSBData > 1000 ));

      // On teste si l'acquisition s'est bien passée
      if (Acq.NbDataUSB = 0) then
        Erreur := E_NO_HARDWARE // aucune donnée recue en NO TRIG : gros problème
    end
    else
      Erreur := E_NO_HARDWARE  ; // problème de _lanceacqui

   SetTriggerSource ( SourceTrigger ) ; // On remet l'ancien type de trigger

  end; // if  Erreur = E_NO_TRIGGER

AcquisitionEnCours := False;
ADC_ABORT();
StartMeasurement := Erreur ;

end;




function ADC_Abort : word ;
begin
  if _StopAcqui(GTIHandle ) = 0 then
    ADC_Abort := E_NO_ERRORS
  else
    ADC_Abort := E_NO_HARDWARE  ;
end;


function GetMeasurementRaw( wCh1 : PTWArray;wCh2: PTWArray) : word ;
var i,j : integer;
    cpt, maxi: integer;
begin
  GetMeasurementRaw := E_NO_ERRORS;

  if Acq.NbDataUSB > 0 then  // s'il y a des données  numéro 1
  begin
// on récupère les données du GetUSBData lancé dans le startmesurement
    cpt :=0;
    if GetCh1InputOn = 1  then
    begin
      for i := 0 to  DataGTI.lDataLen1 - 1 do
      begin
        if DataGTI.bBufferIn1[i] <= 8192  then
        Ch1WordArray[ cpt + i ] := 32767 + 4 *  DataGTI.bBufferIn1[i]
      else
        Ch1WordArray[ cpt + i ] := 4 * ( DataGTI.bBufferIn1[i] -  8192 ) ;
      end;
    end;
    if GetCh2InputOn = 1  then
    begin
      for i := 0 to  DataGTI.lDataLen2 - 1 do
      begin
        if DataGTI.bBufferIn2[i] <= 8192  then
          Ch2WordArray[ cpt + i ] := 32767 + 4 *  DataGTI.bBufferIn2[i]
        else
          Ch2WordArray[ cpt + i ] := 4 * ( DataGTI.bBufferIn2[i] -  8192 ) ;
      end;
    end;
    if GetCh3InputOn = 1  then
    begin
      for i := 0 to  DataGTI.lDataLen3 - 1 do
      begin
        if DataGTI.bBufferIn3[i] <= 8192  then
          Ch3WordArray[ cpt + i ] := 32767 + 4 *  DataGTI.bBufferIn3[i]
        else
          Ch3WordArray[ cpt + i ] := 4 * ( DataGTI.bBufferIn3[i] -  8192 ) ;
      end;
    end;
    if GetCh4InputOn = 1  then
    begin
      for i := 0 to  DataGTI.lDataLen4 - 1 do
      begin
        if DataGTI.bBufferIn4[i] <= 8192  then
          Ch4WordArray[ cpt + i ] := 32767 + 4 *  DataGTI.bBufferIn4[i]
        else
          Ch4WordArray[ cpt + i ] := 4 * ( DataGTI.bBufferIn4[i] -  8192 ) ;
      end;
    end;
    maxi := DataGTI.lDataLen1;
    if DataGTI.lDataLen2 > maxi then maxi := DataGTI.lDataLen2;
    if DataGTI.lDataLen3 > maxi then maxi := DataGTI.lDataLen3;
    if DataGTI.lDataLen4 > maxi then maxi := DataGTI.lDataLen4;
    cpt := cpt + maxi;
// on récupère ensuite le reste des données en lancant des GetUSBData
    repeat
      Acq.NbDataUSB :=_getusbdata(GTIHandle, DataGTI , DataAcq);
      if Acq.NbDataUSB > 0 then  // s'il y a des données numéro 2
      begin
        if GetCh1InputOn = 1  then
        begin
          for i := 0 to  DataGTI.lDataLen1 - 1 do
          begin
            if DataGTI.bBufferIn1[i] <= 8192  then
              Ch1WordArray[ cpt + i ] := 32767 + 4 *  DataGTI.bBufferIn1[i]
            else
              Ch1WordArray[ cpt + i ] := 4 * ( DataGTI.bBufferIn1[i] -  8192 ) ;
          end;
        end;
        if GetCh2InputOn = 1  then
        begin
          for i := 0 to  DataGTI.lDataLen2 - 1 do
          begin
            if DataGTI.bBufferIn2[i] <= 8192  then
              Ch2WordArray[ cpt + i ] := 32767 + 4 *  DataGTI.bBufferIn2[i]
            else
              Ch2WordArray[ cpt + i ] := 4 * ( DataGTI.bBufferIn2[i] -  8192 ) ;
          end;
        end;
        if GetCh3InputOn = 1  then
        begin
          for i := 0 to  DataGTI.lDataLen3 - 1 do
          begin
            if DataGTI.bBufferIn3[i] <= 8192  then
               Ch3WordArray[ cpt + i ] := 32767 + 4 *  DataGTI.bBufferIn3[i]
            else
              Ch3WordArray[ cpt + i ] := 4 * ( DataGTI.bBufferIn3[i] -  8192 ) ;
          end;
        end;
        if GetCh4InputOn = 1  then
        begin
          for i := 0 to  DataGTI.lDataLen4 - 1 do
          begin
            if DataGTI.bBufferIn4[i] <= 8192  then
              Ch4WordArray[ cpt + i ] := 32767 + 4 *  DataGTI.bBufferIn4[i]
            else
              Ch4WordArray[ cpt + i ] := 4 * ( DataGTI.bBufferIn4[i] -  8192 ) ;
          end;
        end;
        maxi := DataGTI.lDataLen1;
        if DataGTI.lDataLen2 > maxi then maxi := DataGTI.lDataLen2;
        if DataGTI.lDataLen3 > maxi then maxi := DataGTI.lDataLen3;
        if DataGTI.lDataLen4 > maxi then maxi := DataGTI.lDataLen4;
        cpt := cpt + maxi;
      end // if  usbdata >0 numéro 2

      else
      begin   // if usbdata =0 numéro 2
        GetMeasurementRaw := E_NOT_SUPPORTED ;
      end;
    until  ( cpt >= Acq.RecordLength ) or ( Acq.NbDataUSB = 0 );

    if cpt<Acq.RecordLength then
      GetMeasurementRaw := E_NOT_SUPPORTED ; // Pas assez de données sont arrivées
    end // if Acq.NbDataUSB > 0 numéro 1

  else
  begin   // if usbdata =0   numéro 1
    GetMeasurementRaw := E_NOT_SUPPORTED ;
  end;
end;


function GetMeasurement (dCh1 : PDArray;dCh2: PDArray): word;
var  i       : integer;
     erreur  : longint;
     calibre : double;
begin
  erreur:=GetMeasurementRaw(@Ch1WordArray,@Ch2WordArray);
  GetMeasurement := erreur;
  if erreur = E_NO_ERRORS then
  begin
//  for i := 0 to {131092}512 * 1024 - 1 do
    for i := 0 to Tgti2MAX-1 do
    begin
      if (GetCh1InputOn = 1 ) and (GetSensitivity(1,@calibre)= E_NO_ERRORS )then
         if ( GetCh1DiffOn = 1 )
         then Ch1DoubleArray[i] := calibre * (Ch1WordArray[i] - 32767 ) / 32767 + Acq.Correction_Amplitude_Differentielle[1]
         else Ch1DoubleArray[i] := calibre * (Ch1WordArray[i] - 32767 ) / 32767 + Acq.Correction_Amplitude_Unipolaire[1];
      if (GetCh2InputOn = 1 ) and (GetSensitivity(2,@calibre)= E_NO_ERRORS ) then
         if ( GetCh2DiffOn = 2 )
         then Ch2DoubleArray[i] := calibre * (Ch2WordArray[i] - 32767 ) / 32767 + Acq.Correction_Amplitude_Differentielle[2]
         else Ch2DoubleArray[i] := calibre * (Ch2WordArray[i] - 32767 ) / 32767 + Acq.Correction_Amplitude_Unipolaire[2];
      if (GetCh3InputOn = 1 ) and (GetSensitivity(3,@calibre)= E_NO_ERRORS ) then
         if ( GetCh3DiffOn = 1 )
         then Ch3DoubleArray[i] := calibre * (Ch3WordArray[i] - 32767 ) / 32767 + Acq.Correction_Amplitude_Differentielle[3]
         else Ch3DoubleArray[i] := calibre * (Ch3WordArray[i] - 32767 ) / 32767 + Acq.Correction_Amplitude_Unipolaire[3];
      if (GetCh4InputOn = 1 ) and (GetSensitivity(4,@calibre)= E_NO_ERRORS ) then
         if ( GetCh4DiffOn = 1 )
         then Ch4DoubleArray[i] := calibre * (Ch4WordArray[i] - 32767 ) / 32767 + Acq.Correction_Amplitude_Differentielle[4]
         else Ch4DoubleArray[i] := calibre * (Ch4WordArray[i] - 32767 ) / 32767 + Acq.Correction_Amplitude_Unipolaire[4];
    end;
  end;

end;

function SetMeasureMode ( ByMode : byte ) : word ;
begin
  SetMeasureMode := E_NO_ERRORS ;
  case Bymode of
    1 :
    begin
      SetCh1InputON(1);
      SetCh2InputON(0);
    end;
    2 :
    begin
      SetCh1InputON(0);
      SetCh2InputON(1);
    end;
    3 :
    begin
      SetCh1InputON(1);
      SetCh2InputON(1);
    end
  else
    SetMeasureMode := E_INVALID_VALUE ;
  end;
end;

function GetMeasureMode ( byMode      : Pbyte  ) : word;
begin
  //a faire fft?
end;

function GetMaxRecordLength : dword ;
begin
 GetMaxRecordLength := 16000 ;
end;

function SetRecordLength (dTotal : dword) : word ;
begin
  if dTotal <= GetMaxRecordLength then
  begin
    Acq.RecordLength:= dTotal ;
    SetRecordLength := E_NO_ERRORS ;
  end
  else
    SetRecordLength := E_INVALID_VALUE ;
end;

function GetRecordLength : dword ;
begin
 GetRecordLength := Acq.RecordLength;
end;

function SetPostSamples (dPost : dword) : word ;
begin  //pas de pretrig
  if dPost = Acq.RecordLength then
    SetPostSamples := E_NO_ERRORS
  else
    SetPostSamples := E_INVALID_VALUE ;
end;

function GetPostSamples : word;
begin
  GetPostSamples := Acq.RecordLength;
  //pas de pretrig
end;

function GetMaxSampleFrequency : dword ;
begin
 GetMaxSampleFrequency := 10000000 ;
end;

function SetSampleFrequency( dFrequency       : Pdword  ) : word;
var cpt : integer;
begin
SetSampleFrequency := E_NO_ERRORS ;

  if dFrequency^ < Acq.Frequence[Acq.NbFrequences - 1] then
  begin
    cpt := 0 ;
    // recherche de la frequence la plus proche
    repeat
      cpt := cpt + 1 ;
    until dFrequency^ <= Acq.Frequence[cpt];
    // choix entre les 2 fréquences les plus proches
    if (cpt >0) and (Acq.Frequence[cpt]-dFrequency^ > dFrequency^-Acq.Frequence[cpt-1]) then
    cpt := cpt - 1 ;
  end
  else
    cpt := Acq.NbFrequences - 1 ; // freq = 10 MHz

  dFrequency^ := Acq.Frequence[cpt];
  Acq.IndiceFrequence := cpt ;

  DataAcq.Config.BaseDeTemps:=Acq.BaseDeTemps[Acq.IndiceFrequence];
  DataAcq.Config.Reload:=Acq.Reload[Acq.IndiceFrequence];
  DataAcq.Config.UnSurN:=Acq.UnSurN[Acq.IndiceFrequence];

end;

function GetSampleFrequency : dword ;
begin
  GetSampleFrequency := Acq.Frequence[Acq.IndiceFrequence] ;
end;


function GetSampleFrequencyPossible( dFrequency       : Pdword  ) : dword;
var cpt : integer;
begin

  if dFrequency^ < Acq.Frequence[Acq.NbFrequences - 1] then
  begin
    cpt := 0 ;
    // recherche de la frequence la plus proche
    repeat
      cpt := cpt + 1 ;
    until dFrequency^ <= Acq.Frequence[cpt];
    // choix entre les 2 fréquences les plus proches
    if (cpt >0) and (Acq.Frequence[cpt]-dFrequency^ > dFrequency^-Acq.Frequence[cpt-1]) then
    cpt := cpt - 1 ;
  end
  else
    cpt := Acq.NbFrequences - 1 ; // freq = 10 MHz

GetSampleFrequencyPossible:=Acq.Frequence[cpt];
end;






function GetAvailableSensitivities(dSensitivities :pTab20double): word;
var i : integer;
begin
dSensitivities[0]:= 7.5 ;
dSensitivities[1]:= 15 ;
   for i := 2 to 19 do
   dSensitivities[i] :=0 ;
GetAvailableSensitivities := E_NO_ERRORS ; // fonction marche toujours
end;

function SetSensitivity ( byCh : byte; dSens : PDouble ): word  ;
begin
  if dSens^ <= 7.5 then
  begin
    dSens^ := 7.5 ;
    DataAcq.Voie[byCh - 1].Calibre := 1 ;
  end
  else
  begin
    dSens^ := 15 ;
    DataAcq.Voie[byCh - 1].Calibre := 0 ;
  end;
  SetSensitivity:=0;
end;

function GetSensitivity ( byCh : byte;dSens: PDouble ) : word ;
begin
GetSensitivity := E_NO_ERRORS;
  if byCh <= 4 then
  begin
    case DataAcq.Voie[byCh-1].Calibre of
      0 : dSens^ := 15 ;
      1 : dSens^ := 7.5 ;
    else
    dSens^ := 0 ;
    GetSensitivity := E_INVALID_VALUE;
    end;
  end
  else
  GetSensitivity := E_INVALID_VALUE;
end;

function SetCoupling ( byCh  : byte;byMode : byte ): word ;
begin
  if byMode = lctDC then
    SetCoupling := E_NO_ERRORS
  else
    SetCoupling := E_NOT_SUPPORTED ;
end;

function GetCoupling ( byCh        : byte;    byMode      : Pbyte  ) : word;
begin
  byMode^ := lctDC ;
  GetCoupling := E_NO_ERRORS ;
end;

function SetAutoRanging ( byCh        : byte;    byMode      : byte  ) : word;
begin
  if byMode = 0 then
    SetAutoRanging := E_NO_ERRORS
  else
    SetAutoRanging := E_NOT_SUPPORTED ;
end;

function GetTriggerSource( bySource    : pbyte ) : word;
begin
GetTriggerSource := E_NO_ERRORS ;
  Case DataAcq.Trig.TrigOn of
    0 : bySource^ := ltsNoTrig ;
    1 : bySource^ := ltsCh1 ;
    2 : bySource^ := ltsCh2 ;
    3 : bySource^ := ltsCh3 ;
    4 : bySource^ := ltsCh4 ;
  else
    GetTriggerSource := E_INVALID_VALUE;
  end;

end;

function SetTriggerSource( bysource    : byte ):word;
begin
SetTriggerSource := E_NO_ERRORS ;
  Case bysource of
    ltsNoTrig  : DataAcq.Trig.TrigOn := 0 ;
    ltsCh1     : DataAcq.Trig.TrigOn := 1 ;
    ltsCh2     : DataAcq.Trig.TrigOn := 2 ;
    ltsCh3     : DataAcq.Trig.TrigOn := 3 ;
    ltsCh4     : DataAcq.Trig.TrigOn := 4 ;
  else
    SetTriggerSource := E_INVALID_VALUE ;
 end;
end;

function SetTriggerHys ( byCh : byte; dHysteresis : double ) :word;
begin
 if dHysteresis = 0 then
   SetTriggerHys := E_NO_ERRORS
 else
   SetTriggerHys := E_NOT_SUPPORTED ;
end;

function SetTriggerTimeOUT ( lTimeout    : dword ) : word;
begin
  if lTimeOut < 100000 then
  begin
    Acq.TriggerTimeOut := lTimeOut;
    SetTriggerTimeOUT := E_NO_ERRORS
  end
  else
  SetTriggerTimeOUT := E_NOT_SUPPORTED ;
end;

function GetTriggerTimeout : word;
begin
  GetTriggerTimeout := Acq.TriggerTimeOut ;
end;

function SetTriggerLevel( byCh : byte;    dLevel  : double ) : word;
//var
//GTILevel:double;
begin
  if ( dLevel >= -15 ) and ( dLevel <= 15 ) and ( byCh <=4 ) then
 // if ( dLevel >= 0 ) and ( dLevel <= 4095 ) and ( byCh <=4 ) then
  begin
   // GTILevel:=dLevel+15*(4096/30);
   // Acq.TriggerLevel[byCh] := GTILevel;
    Acq.TriggerLevel[byCh] := dLevel;   //VALEURS EN VOLTS, dépendant de chaques voies, a recalculer pour GTI2 [0..4095] ds le startmeasurement
    SetTriggerLevel := E_NO_ERRORS ;
  end
  else
    SetTriggerLevel := E_INVALID_VALUE ;
end;

function SetTriggerMode ( byMode      : Byte ) : word;
begin
SetTriggerMode := E_NO_ERRORS ;
  case byMode of
    ltkFalling : DataAcq.Trig.FrontMontant := 0;
    ltkRising  : DataAcq.Trig.FrontMontant := 1;
  else
    DataAcq.Trig.FrontMontant := E_INVALID_VALUE;
  end;
end;

function GetTriggerMode ( byMode      : pByte  ) : word;
begin
GetTriggerMode := E_NO_ERRORS ;
  case DataAcq.Trig.FrontMontant of
    0 : byMode^ := ltkFalling ;
    1 : byMode^ := ltkRising ;
  else
    GetTriggerMode := E_INVALID_VALUE ;
  end;
end;

function SetTriggerPreTrig ( byMode      : Byte ) : word;
begin
SetTriggerPreTrig := E_NO_ERRORS ;
  case byMode of
    0 : DataAcq.Trig.PreTrigOn := 0;
    1 : DataAcq.Trig.PreTrigOn := 1;
  else
    DataAcq.Trig.FrontMontant := E_INVALID_VALUE;
  end;
end;






function StartMeasurementFrancois : word ;
begin
// si trigger on fournit le level de la voie triggeuse
  if DataAcq.Trig.TrigOn > 0 then
     DataAcq.Trig.Valeur :=  round (2048 +  2047 * Acq.TriggerLevel[ DataAcq.Trig.TrigOn] / 15 ) ;
{ SetCh3InputOn(1);
DataAcq.Trig.TrigOn:=1;
DataAcq.Trig.PreTrigOn:=0;
DataAcq.Trig.FrontMontant:=1;
DataAcq.Trig.Valeur:=2048;
}
  if _lanceacqui(GTIHandle, DataAcq ) = 0 then
    StartMeasurementFrancois := E_NO_ERRORS
  else
    StartMeasurementFrancois := E_NO_HARDWARE  ;
end;




function GetMeasurementRawFrancois( wCh1 : PTWArray;wCh2: PTWArray) : word ;
var i,j : integer;
    cpt, maxi: integer;
    cpt1,cpt2,cpt3,cpt4 : integer;
    NbDataUSB : integer;
    NbVoies : integer;
    NbPtsTotal : integer;
    compteur :integer;
    TRIGstart:boolean;
begin
  GetMeasurementRawFrancois := E_NO_ERRORS;

 cpt :=0;
cpt1 :=0;
cpt2 :=0;
cpt3 :=0;
cpt4 :=0;

NbPtsTotal:=0;
Compteur:=0;
TRIGstart:=false;

// Calcul Nb Voies
  NbVoies:=0;
  if GetCh1InputOn = 1  then  Nbvoies:=Nbvoies+1;
  if GetCh2InputOn = 1  then  Nbvoies:=Nbvoies+1;
  if GetCh3InputOn = 1  then  Nbvoies:=Nbvoies+1;
  if GetCh4InputOn = 1  then  Nbvoies:=Nbvoies+1;
 // while _getusbdata(GTIHandle, DataGTI ,DataAcq) > 0 do // >= temporairement :test passe tout le temps   MERLE : origine du PB des trame de début répétitive
 // for j := 0 to trunc ((Acq.RecordLength - 1 )/128 ) do
  //begin
    repeat
    NbDataUSB :=_getusbdata(GTIHandle, DataGTI , DataAcq);
    if NbDataUSB > 0 then  // s'il y a des données
    begin             //PB si pas de point de trigger : ON n'en sort JAMAIS!!!!!!
      TRIGstart := true;      //au premier getusbdata<>0 on sait que le trigger a déclenché!!!!!
      if GetCh1InputOn = 1  then
      begin
        for i := 0 to  DataGTI.lDataLen1 - 1 do
        begin
          if DataGTI.bBufferIn1[i] <= 8192  then
          wCh1[ cpt + i ] := 32767 + 4 *  DataGTI.bBufferIn1[i]
        else
          wCh1[ cpt + i ] := 4 * ( DataGTI.bBufferIn1[i] -  8192 ) ;
        end;
      end;
      if GetCh2InputOn = 1  then
      begin
        for i := 0 to  DataGTI.lDataLen2 - 1 do
        begin
          if DataGTI.bBufferIn2[i] <= 8192  then
            wCh2[ cpt + i ] := 32767 + 4 *  DataGTI.bBufferIn2[i]
          else
            wCh2[ cpt + i ] := 4 * ( DataGTI.bBufferIn2[i] -  8192 ) ;
        end;
      end;
      if GetCh3InputOn = 1  then
      begin
        for i := 0 to  DataGTI.lDataLen3 - 1 do
        begin
          if DataGTI.bBufferIn3[i] <= 8192  then
            Ch3WordArray[ cpt + i ] := 32767 + 4 *  DataGTI.bBufferIn3[i]
          else
            Ch3WordArray[ cpt + i ] := 4 * ( DataGTI.bBufferIn3[i] -  8192 ) ;
        end;
      end;
      if GetCh4InputOn = 1  then
      begin
        for i := 0 to  DataGTI.lDataLen4 - 1 do
        begin
          if DataGTI.bBufferIn4[i] <= 8192  then
            Ch4WordArray[ cpt + i ] := 32767 + 4 *  DataGTI.bBufferIn4[i]
          else
            Ch4WordArray[ cpt + i ] := 4 * ( DataGTI.bBufferIn4[i] -  8192 ) ;
        end;
      end;

      NbPtsTotal := NbPtsTotal + round( NbDataUSB / NbVoies );
   //   cpt := cpt + NBptsTOTAL;

      cpt1 := cpt1+DataGTI.lDataLen1;
      cpt2 := cpt2+DataGTI.lDataLen2;
      cpt3 := cpt3+DataGTI.lDataLen3;
      cpt4 := cpt4+DataGTI.lDataLen4;

    end // if  usbdata >0
    else
    begin   // if usbdata =0
     // GetMeasurementRaw := E_NOT_SUPPORTED ;
      compteur:=compteur+1;
    end;

  maxi := DataGTI.lDataLen1;
  if DataGTI.lDataLen2 > maxi then maxi := DataGTI.lDataLen2;
  if DataGTI.lDataLen3 > maxi then maxi := DataGTI.lDataLen3;
  if DataGTI.lDataLen4 > maxi then maxi := DataGTI.lDataLen4;
  cpt := cpt + maxi;

 // until ((( cpt > Acq.RecordLength) or ( maxi=0 ))and(LenUSBDATA<>0))or ((compteur=10)and(LenUSBDATA=0))  ;
   until ( (( cpt >= Acq.RecordLength)) or (TRIGstart=false))  ;
   

 // until (( cpt >= Acq.RecordLength-1 ) or (LenUSBDATA=0))  ;
  //until ( cpt >= Acq.RecordLength-1 )   ;
  //until  NBptsTOTAL >= Acq.RecordLength    ;
  if TRIGstart=false then  GetMeasurementRawFrancois := E_NOT_SUPPORTED ;
  if TRIGstart=true  then  GetMeasurementRawFrancois := E_NO_ERRORS ;
end;


function GetMeasurementFrancois (dCh1 : PDArray;dCh2: PDArray): word;
var  i       : integer;
     erreur  : longint;
     calibre : double;
begin
  erreur:=GetMeasurementRawFrancois(@Ch1WordArray,@Ch2WordArray);
  GetMeasurementFrancois := erreur;
  if erreur = E_NO_ERRORS then
  begin
//  for i := 0 to {131092}512 * 1024 - 1 do
    for i := 0 to Tgti2MAX-1 do
    begin

    if (GetCh1InputOn = 1 ) and (GetSensitivity(1,@calibre)= E_NO_ERRORS )then
         if ( GetCh1DiffOn = 1 )
         then Ch1DoubleArray[i] := calibre * (Ch1WordArray[i] - 32767 ) / 32767 + Acq.Correction_Amplitude_Differentielle[1]
         else Ch1DoubleArray[i] := calibre * (Ch1WordArray[i] - 32767 ) / 32767 + Acq.Correction_Amplitude_Unipolaire[1];
      if (GetCh2InputOn = 1 ) and (GetSensitivity(2,@calibre)= E_NO_ERRORS ) then
         if ( GetCh2DiffOn = 2 )
         then Ch2DoubleArray[i] := calibre * (Ch2WordArray[i] - 32767 ) / 32767 + Acq.Correction_Amplitude_Differentielle[2]
         else Ch2DoubleArray[i] := calibre * (Ch2WordArray[i] - 32767 ) / 32767 + Acq.Correction_Amplitude_Unipolaire[2];
      if (GetCh3InputOn = 1 ) and (GetSensitivity(3,@calibre)= E_NO_ERRORS ) then
         if ( GetCh3DiffOn = 1 )
         then Ch3DoubleArray[i] := calibre * (Ch3WordArray[i] - 32767 ) / 32767 + Acq.Correction_Amplitude_Differentielle[3]
         else Ch3DoubleArray[i] := calibre * (Ch3WordArray[i] - 32767 ) / 32767 + Acq.Correction_Amplitude_Unipolaire[3];
      if (GetCh4InputOn = 1 ) and (GetSensitivity(4,@calibre)= E_NO_ERRORS ) then
         if ( GetCh4DiffOn = 1 )
         then Ch4DoubleArray[i] := calibre * (Ch4WordArray[i] - 32767 ) / 32767 + Acq.Correction_Amplitude_Differentielle[4]
         else Ch4DoubleArray[i] := calibre * (Ch4WordArray[i] - 32767 ) / 32767 + Acq.Correction_Amplitude_Unipolaire[4];


    end;
  end;

end;




function GetMeasurementFrancoisTraceur_RAM (dCh1 : PDArray;dCh2: PDArray): word;
var  i,j       : integer;
     erreur  : longint;
     calibre : double;
     calibre1,calibre2,calibre3,calibre4: double;
     CorrectionAmplitude1,CorrectionAmplitude2,CorrectionAmplitude3,CorrectionAmplitude4 : double ;
begin
  erreur:=GetMeasurementRawFrancoisTraceur_RAM(@Ch1WordArray,@Ch2WordArray);
  GetMeasurementFrancoisTraceur_RAM := erreur;
  if erreur = E_NO_ERRORS then
  begin
      for i:=0 to 100-1-DataUsbTRACEUR do                   //teste avec ram de 1000 pts...
      begin
          Ch1DoubleArray[i] := Ch1DoubleArray[i+DataUsbTRACEUR];
          Ch2DoubleArray[i] := Ch2DoubleArray[i+DataUsbTRACEUR];
          Ch3DoubleArray[i] := Ch3DoubleArray[i+DataUsbTRACEUR];
          Ch4DoubleArray[i] := Ch4DoubleArray[i+DataUsbTRACEUR];
      end;

      if (GetCh1InputOn = 1 ) then GetSensitivity(1,@calibre1);
      if (GetCh2InputOn = 1 ) then GetSensitivity(1,@calibre2);
      if (GetCh3InputOn = 1 ) then GetSensitivity(1,@calibre3);
      if (GetCh4InputOn = 1 ) then GetSensitivity(1,@calibre4);

      // Correction des amplitudes en fonction de DIFF/UNIP
      if ( GetCh1DiffOn = 1 ) then CorrectionAmplitude1 := Acq.Correction_Amplitude_Differentielle[1] else CorrectionAmplitude1 :=Acq.Correction_Amplitude_Unipolaire[1];
      if ( GetCh1DiffOn = 2 ) then CorrectionAmplitude2 := Acq.Correction_Amplitude_Differentielle[2] else CorrectionAmplitude2 :=Acq.Correction_Amplitude_Unipolaire[2];
      if ( GetCh1DiffOn = 3 ) then CorrectionAmplitude3 := Acq.Correction_Amplitude_Differentielle[3] else CorrectionAmplitude3 :=Acq.Correction_Amplitude_Unipolaire[3];
      if ( GetCh1DiffOn = 4 ) then CorrectionAmplitude4 := Acq.Correction_Amplitude_Differentielle[4] else CorrectionAmplitude4 :=Acq.Correction_Amplitude_Unipolaire[4];




      for i := 100-DataUsbTRACEUR to 100-1 do
      begin
        j:=i-(100-DataUsbTRACEUR);


        if (GetCh1InputOn = 1 ) then
        Ch1DoubleArray[i] := calibre1 * (Ch1WordArray[j] - 32767 ) / 32767 + CorrectionAmplitude1;
        if (GetCh2InputOn = 1 ) then
        Ch2DoubleArray[i] := calibre2 * (Ch2WordArray[j] - 32767 ) / 32767 + CorrectionAmplitude2;
        if (GetCh3InputOn = 1 ) then
        Ch3DoubleArray[i] := calibre3 * (Ch3WordArray[j] - 32767 ) / 32767 + CorrectionAmplitude3;
        if (GetCh4InputOn = 1 ) then
        Ch4DoubleArray[i] := calibre4 * (Ch4WordArray[j] - 32767 ) / 32767 + CorrectionAmplitude4;
      end;
       {
      for i := 100-1-DataUsbTRACEUR to 100-1 do
      begin
        j:=i-(100-1-DataUsbTRACEUR);
        if (GetCh1InputOn = 1 ) and (GetSensitivity(1,@calibre)= E_NO_ERRORS )then
        Ch1DoubleArray[i] := calibre * (Ch1WordArray[j] - 32767 ) / 32767 ;
        if (GetCh2InputOn = 1 ) and (GetSensitivity(2,@calibre)= E_NO_ERRORS ) then
        Ch2DoubleArray[i] := calibre * (Ch2WordArray[j] - 32767 ) / 32767 ;
        if (GetCh3InputOn = 1 ) and (GetSensitivity(3,@calibre)= E_NO_ERRORS ) then
        Ch3DoubleArray[i] := calibre * (Ch3WordArray[j] - 32767 ) / 32767 ;
        if (GetCh4InputOn = 1 ) and (GetSensitivity(4,@calibre)= E_NO_ERRORS ) then
        Ch4DoubleArray[i] := calibre * (Ch4WordArray[j] - 32767 ) / 32767 ;
      end;
      }
  end;
end;


function GetMeasurementRawFrancoisTraceur_RAM( wCh1 : PTWArray;wCh2: PTWArray) : word ;
var i,j : integer;
    cpt, maxi: integer;


    NbDataUSB : integer;
    NbVoies : integer;
    NbPtsTotal : integer;

    //TRIGstart:boolean;
begin
  //GetMeasurementRawFrancoisTraceur := E_NO_ERRORS;



NbPtsTotal:=0;



// Calcul Nb Voies
  NbVoies:=0;
  if GetCh1InputOn = 1  then  Nbvoies:=Nbvoies+1;
  if GetCh2InputOn = 1  then  Nbvoies:=Nbvoies+1;
  if GetCh3InputOn = 1  then  Nbvoies:=Nbvoies+1;
  if GetCh4InputOn = 1  then  Nbvoies:=Nbvoies+1;


        NbDataUSB :=_getusbdata(GTIHandle, DataGTI , DataAcq);
        if NbDataUSB > 0 then  // s'il y a des données
        begin
            if GetCh1InputOn = 1  then
            begin
                for i := 0 to  DataGTI.lDataLen1 - 1 do
                begin
                    if DataGTI.bBufferIn1[i] <= 8192  then
                    wCh1[ i ] := 32767 + 4 *  DataGTI.bBufferIn1[i]
                    else
                    wCh1[  i ] := 4 * ( DataGTI.bBufferIn1[i] -  8192 ) ;
                end;
            end;
            if GetCh2InputOn = 1  then
            begin
                for i := 0 to  DataGTI.lDataLen2 - 1 do
                begin
                    if DataGTI.bBufferIn2[i] <= 8192  then
                    wCh2[  i ] := 32767 + 4 *  DataGTI.bBufferIn2[i]
                    else
                    wCh2[  i ] := 4 * ( DataGTI.bBufferIn2[i] -  8192 ) ;
                end;
            end;
            if GetCh3InputOn = 1  then
            begin
                for i := 0 to  DataGTI.lDataLen3 - 1 do
                begin
                    if DataGTI.bBufferIn3[i] <= 8192  then
                    Ch3WordArray[  i ] := 32767 + 4 *  DataGTI.bBufferIn3[i]
                    else
                    Ch3WordArray[  i ] := 4 * ( DataGTI.bBufferIn3[i] -  8192 ) ;
                end;
            end;
            if GetCh4InputOn = 1  then
            begin
                for i := 0 to  DataGTI.lDataLen4 - 1 do
                begin
                    if DataGTI.bBufferIn4[i] <= 8192  then
                    Ch4WordArray[  i ] := 32767 + 4 *  DataGTI.bBufferIn4[i]
                    else
                    Ch4WordArray[  i ] := 4 * ( DataGTI.bBufferIn4[i] -  8192 ) ;
                end;
            end;

          maxi := DataGTI.lDataLen1;
          if DataGTI.lDataLen2 > maxi then maxi := DataGTI.lDataLen2;
          if DataGTI.lDataLen3 > maxi then maxi := DataGTI.lDataLen3;
          if DataGTI.lDataLen4 > maxi then maxi := DataGTI.lDataLen4;

       //   cptTRACEUR:=cptTRACEUR+ maxi;

          DataUsbTRACEUR:=maxi;
          GetMeasurementRawFrancoisTraceur_RAM := E_NO_ERRORS ;
        end // if  usbdata >0
        else
        begin   // if usbdata =0
            DataUsbTRACEUR:=0;
            GetMeasurementRawFrancoisTraceur_RAM := E_NO_DATA ;
        end;   // if usbdata =0

     //   if cptTRACEUR>10000 then
     //   begin
     //       ADC_ABORT();
     //   end;
end;


end.




